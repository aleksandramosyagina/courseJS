<!-- 1) Подробно прочитать про метод запроса OPTIONS - и кратко его описать, когда вызывается, где используется, что передает и принимает. 

HTTP-метод OPTIONS используется для описания параметров соединения с целевым ресурсом. Этот метод позволяет клиенту определять опции и/или требования, связанные с ресурсом, или возможностями сервера, но не производя никаких действий над ресурсом и не инициируя его загрузку.

Клиент может указать особый URL для обработки метода OPTIONS, или * (звёздочку) чтобы указать весь сервер целиком.

Синтаксис:

OPTIONS /index.html HTTP/1.1  
OPTIONS * HTTP/1.1


Сервер отвечает на запрос с методом OPTIONS только опциями соединения, например он посылает поля заголовков Allow, но не пошлет Content-Type, ответы сервера на запросы с методом OPTIONS не кэшируются. Если в качестве URI указана звездочка «*», то параметры соединения передаются для сервера в целом, а не для какого-то конкретного URL. Этот метод не самый безопасный для HTTP сервера, поэтому зачастую клиенты его не могут применять из-за настроек безопасности.

Пример запроса с HTTP методом OPTIONS:

OPTIONS * HTTP/1.1
User-Agent: Mozilla/4.0 (compatible; MSIE5.01; Windows NT)


А примерно так ответит сервер на запрос с методом OPTIONS:

HTTP/1.1 200 OK  
Date: Mon, 27 Jul 2009 12:28:53 GMT  
Server: Apache/2.2.14 (Win32)  
Allow: GET,HEAD,POST,OPTIONS,TRACE  
Content-Type: httpd/unix-directory

2) Прочитать и описать ключевые особенности "HTTP" Версии 3.0

HTTP/3 — готовящаяся к стандартизации версия протокола HTTP (HyperText Transfer Protocol). Главное его отличие от предыдущих версий в том, что он использует новый транспортный протокол QUIC, и за счёт этого передаёт данные быстрее.

Итак, главное преимущество HTTP/3 над HTTP/2 в том, что он быстрее за счёт использования QUIC:

Быстрее устанавливается соединение.  
Быстрее передаются пакеты.  
Лучше работает мультиплексирование.


QUIC (Quick UDP Internet Connection) — транспортный протокол, основанный на UDP. Был разработан Google в 2012 году.

QUIC включает в себя TLS 1.3, обеспечивает безопасное зашифрованное соединение, но при этом не требует такого количества «рукопожатий» как в TCP- и TLS-соединении.

Зашифрованное соединение устанавливается сразу. «Рукопожатие» проходит за 3 шага. А если это повторное соединение, то первые данные отправляются одновременно с «рукопожатием».

Всё это позволяет QUIC передавать данные в несколько раз быстрее TCP и при этом обеспечивать высокий уровень безопасности.

- Мультиплексирование. QUIC может передавать несколько потоков данных параллельно, чего не умеет TCP.
- Если часть данных в каком-то пакете была утеряна, QUIC не будет передавать весь пакет заново. Он отправит только утерянный фрагмент.
- Потеря информации влияет на доставку только того потока, к которому эта информация относилась. Все остальные потоки данных продолжают передаваться без остановки.

В QUIC нет привязки к конкретному IP. В этом протоколе вместо адресов и портов используется идентификатор соединения — Connection UUID. И он не меняется при переходе от Wi-Fi на мобильную сеть. А значит, соединение остаётся, и ничего не нужно открывать заново.


3) Прочитать про способы отмены запроса, включая объект "AbortController" 

Наиболее распространенный способ отправки запросов в JavaScript - через XMLHttpRequest (XHR) объект. Этот объект предоставляет способ отправлять HTTP или HTTPS запросы и получать ответы асинхронно. Чтобы отменить запрос, который отправляется с помощью XMLHttpRequest, мы можем использовать abort() метод объекта.
abort() Метод немедленно останавливает запрос и присваивает readyState свойству значение 0. Это означает, что onreadystatechange событие не будет запущено, и события onload и onerror также не будут запущены. И это запускает abort событие.
fetch() API - это современный способ отправки HTTP или HTTPS-запросов в JavaScript. Он предоставляет более простой и гибкий интерфейс, чем XMLHttpRequest. Чтобы отменить запрос, который отправляется с помощью fetch(), мы можем использовать AbortController интерфейс.
AbortController Интерфейс предоставляет способ отменить запросы на выборку, вызвав свой abort() метод. Мы можем создать новый AbortController объект и передать его в signal опцию fetch() метода. Затем, когда мы захотим отменить запрос, мы можем вызвать abort() метод AbortController объекта.
Отмена запроса с помощью Axios
Axios - популярная библиотека для создания HTTP-запросов на JavaScript. Она предоставляет простой в использовании интерфейс и поддерживает множество функций, таких как перехват запросов и ответов, автоматические повторные попытки и многое другое. Чтобы отменить запрос, отправляемый с помощью Axios, мы можем использовать CancelToken функцию.
CancelToken Функция предоставляет способ отменить запросы Axios путем создания нового CancelToken объекта и передачи его в cancelToken опцию объекта конфигурации запроса Axios. Затем, когда мы захотим отменить запрос, мы можем вызвать cancel() метод CancelToken объекта.
Когда вам действительно нужна отмена тайм-аута, вы можете просто использовать AbortSignal.timeout(). Он возвращает AbortSignal, который автоматически прервется по истечении указанного времени.



4) Написать по 2 примера создания примитивных значений (если есть несколько способов - использовать) (string, number, boolean, null, undefined, symbol, bigInt)

1. String

1- Строку можно создать с помощью одинарных, двойных либо обратных кавычек:

let single = 'single-quoted';
let double = "double-quoted";
let backticks = backticks;

2- С помощью конкатенации (сложение/объединение строк). Или сложение строки с чем-то: с каким-либо другим типом данных. При этом происходит преобразование в строку этого типа данных.

console.log(typeof('ww' + 4)); //string

3- Для преобразования числа в строку у него можно вызвать специальный метод toString():

const num = 10;
console.log(num.toString()); // 10


2. Number

1- Объект Number представляет числа. Чтобы создать число, надо передать в конструктор Number число или строку, представляющую число:

const x = new Number(34);
const y = new Number('34');

2- Создавать объект Number можно и просто присвоив переменной определенное число:

const z = 34;

3- parseFloat(): преобразует строку в число с плавающей точкой:

const a = Number.parseFloat("34.90"); // 34.9

4- parseInt(): преобразует строку в целое число:
const a = Number.parseInt("34.90"); // 34

3. Преобразование в булевы значения

1) Всегда конвертируются в false: 0 (ноль), '' (пустая строка), null, undefined и NaN.
Строка, содержащая пробел - это уже не пустая строка.


let switcher = 1;

if(switcher){ // --> true
    console.log('Hello');
} //Hello

2) Команда Boolean

console.log(Boolean(null)); //false

Такой способ конвертации различных типов данных в булевы значения используется редко.

3) Два отрицания !!

console.log(!!'hi'); //true

4. null

var foo = null;
let b = null;

Как определить наличие значения null у переменной:
единственно правильным методом выяснения значения null является строгое сравнение переменной с объектом null:

x === null

Строго говоря, это не единственный способ. Можно еще использовать Object.is:

Object.is(null, null) // true

Но последний метод рекомендуется использовать только лишь в случаях реальной необходимости.

5. underfined

1- 

var x;
typeof x  // undefined

2-

let key = undefined;

6. Symbol

Для создания символа можно использовать встроенную функцию Symbol().

const x = Symbol()

7. BigInt

BigInt создаётся путём добавления n в конец целочисленного литерала — 10n — или вызовом функции BigInt().

const theBiggestInt = 9007199254740991n;

const alsoHuge = BigInt(9007199254740991);
// 9007199254740991n


5) Почему, если обратиться к переменным созданным через let, const до их объявления - мы получаем ReferenceError? 


Попытавшись обратиться к let или const-переменной до ее объявления, мы получаем ошибку, и происходит это из-за временной мертвой зоны (temporal dead zone, TDZ).
TDZ начинается в начале области видимости переменной и заканчивается ее объявлением. Обращение к переменной в TDZ приводит к выбросу ReferenceError.
Вот пример понятного блока, показывающего начало и конец временной мертвой зоны foo:

{
   // Начало TDZ для foo
    let bar = 'bar';
  console.log(bar); // "bar"
  console.log(foo); // ReferenceError, потому что мы в  TDZ
  let foo = 'foo';  // Конец TDZ для foo
}

6) const res = "B" + "a" + (1 - "hello");
console.log(res); // BaNaN

Если из числа вычесть строку, будет NaN.
Когда прибавляем к строке NaN, он тоже превращается в строку.


const res2 = (true && 3) + "d";
console.log(res2); // 3d

3 == true 
true && 3 выводит последний true результат (3)
3 + "d" == 3d


const res3 = Boolean(true && 3) + "d";
console.log(res3); // trued -->
