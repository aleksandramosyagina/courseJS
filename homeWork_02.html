<!-- Задание 1 – Создать объект counter всеми возможными способами;

let counter = new Object();

let counter = {}; 

let counter = Object.create(null);


Метод Object.assign() используется для копирования свойств из одного или нескольких объектов в объект, переданный в метод первым аргументом. Копирование с помощью Object.assign() является неглубоким (поверхностным). Это означает, что вложенные объекты или массивы будут копироваться в новый объект по ссылке из исходного.

const obj = { a: 1 };
let counter = Object.assign({}, obj);




Задание 2 – Скопировать объект counter всеми
возможными способами;


1. При копировании переменной объекта копируется ссылка, но сам объект не дублируется.

let counter = { name: "John" };

let admin = counter; // копируется ссылка

Теперь у нас есть две переменные, каждая из которых содержит ссылку на один и тот же объект. 
Мы можем использовать любую переменную для доступа к объекту и изменения его содержимого.


2. Если нам нужно создать независимую копию, то то нам нужно создать новый объект и воспроизвести структуру существующего, перебрав его свойства и скопировав их на примитивном уровне.

let user = {
  name: "John",
  age: 30
};

let clone = {}; // новый пустой объект

// давайте скопируем все свойства user в него
for (let key in user) {
  clone[key] = user[key];
}

// теперь clone это полностью независимый объект с тем же содержимым
clone.name = "Pete"; // изменим в нём данные

alert( user.name ); // все ещё John в первоначальном объекте

3. Также мы можем использовать для этого метод Object.assign.

Синтаксис:

Object.assign(dest, [src1, src2, src3...])

Например, мы можем использовать его для объединения нескольких объектов в один:

let counter = { name: "John" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

// копируем все свойства из permissions1 и permissions2 в counter
Object.assign(counter, permissions1, permissions2);

// теперь counter = { name: "John", canView: true, canEdit: true }

4. Копирование с помощью spread оператора. Простое поверхностное копирование с помощью спреда:

// Поверхностное копирование
const copyOfCounter = { ...counter };
// Object.assign({}, counter);

Глубокое копирование:

1. Использование сторонних библиотек (например, lodash)

2. Использование методов  JSON.stringify() и JSON.parse()

нужно сериализовать копируемый объект в JSON и тут же распарсить его. В результате появится полная копия объекта:

const deep = JSON.parse(JSON.stringify(counter))
console.log(counter[1] === deep[1])
// false

3. Создание своей функции для глубокого копирования.

4. Реализация паттерна проектирования прототип (Prototype) для классов, экземпляры которых нужно копировать.



Задание 3 – Создать функцию makeCounter всеми описанными и возможными способами:

1. Function declaration:

function makeCounter() {
let count = 0;
count++;
return count;
  };


2. Function expression:

let makeCounter = function() {
let count = 0;
count++;
 return count;
  };


3. Стрелочная функция

let makeCounter = () => {
    let count = 0;
count++;
  return count;
}
 
makeCounter();

4. Именованное функциональное выражение (named function expression):

let m = function makeCounter() {
let count = 0;
count++;
 return count;
  };

console.log( m(1) );

5. Анонимной в JavaScript называют функцию с которой не связано никакое имя или другими словами у такой функции нет имени.

6. Самовызывающаяся функция - такая анонимная функция выполнится сразу же, как интерпретатор до неё дойдет. В такой записи, функция заключается в круглые скобки (), а после нее добавляется вызов ().

 (function() {
       let count = 0;
count++;
 return count;
    })();

7. Callback-функция – это функция которая передается в другую функцию в качестве аргумента и вызывается внутри переданной функции. Это позволяет выполнять определенные действия после завершения основной функции.

Пример:
Мы вызываем callback внутри функции makeCounter. При вызове функции передадим ей два параметра: имя и callback функцию.

function makeCounter(number, callback){
    let count = number;
count++;
 return count;
    callback();
};

function makeCounter('3', function(){
    console.log('Done');
})


Вторая функция выполнится строго после выполнения первой функции. Что нам и требуется.

8. Функции-конструкторы технически являются обычными функциями. Но есть два соглашения:

Имя функции-конструктора должно начинаться с большой буквы.
Функция-конструктор должна выполняться только с помощью оператора "new".

let Counter = function (number) {
this.number = number;
this.makeCounter = function () {
return this.number++;
};
};

let firstCounter = new Counter(1);
console.log(firstCounter.makeCounter() ); -->
